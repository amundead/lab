pipeline {
    agent any

    environment {
        HARBOR_REGISTRY = 'bakul.mod.gov.my'
        DOCKERFILE_LOCATION = './Dockerfile'
        PATH_YAML = 'deploy-dev/argo_deploy.yaml'
        ARGOCD_SERVER = 'kargo.mod.gov.my'
    }

    parameters {
        choice(name: 'ACTION', choices: ['Build and Push Image', 'Push Image Only'], description: 'Choose whether to build a new image or push an existing one')
        string(name: 'BASE_IMAGE_NAME', defaultValue: '', description: 'Full image name with tag (e.g., testing-app/node-helloworld:v1.00)')
        string(name: 'APP_NAME', defaultValue: '', description: 'Name of the Argo CD application to sync')
        string(name: 'GIT_URL', defaultValue: '', description: 'GitHub repository URL (e.g., https://github.com/amundead/test-repo.git)')
    }

    stages {
        stage('Checkout') {
            steps {
                // Checkout the source code from the GitHub repository
                git url: "${params.GIT_URL}", branch: 'main'
            }
        }

        stage('Build and Push Image') {
            when {
                expression { params.ACTION == 'Build and Push Image' }
            }
            steps {
                script {
                    // Build the Docker image
                    sh "docker build -t ${HARBOR_REGISTRY}/${params.BASE_IMAGE_NAME} -f ${DOCKERFILE_LOCATION} ."
                }
                script {
                    // Push the Docker image to Harbor
                    withCredentials([usernamePassword(credentialsId: 'harbor-credentials-amir', passwordVariable: 'HARBOR_PASSWORD', usernameVariable: 'HARBOR_USERNAME')]) {
                        sh """
                            echo $HARBOR_PASSWORD | docker login ${HARBOR_REGISTRY} -u $HARBOR_USERNAME --password-stdin
                            docker push ${HARBOR_REGISTRY}/${params.BASE_IMAGE_NAME}
                        """
                    }
                }
            }
        }

        stage('Push Image Only') {
            when {
                expression { params.ACTION == 'Push Image Only' }
            }
            steps {
                script {
                    // Push an existing image to Harbor
                    withCredentials([usernamePassword(credentialsId: 'harbor-credentials-amir', passwordVariable: 'HARBOR_PASSWORD', usernameVariable: 'HARBOR_USERNAME')]) {
                        sh """
                            echo $HARBOR_PASSWORD | docker login ${HARBOR_REGISTRY} -u $HARBOR_USERNAME --password-stdin
                            docker push ${HARBOR_REGISTRY}/${params.BASE_IMAGE_NAME}
                        """
                    }
                }
            }
        }

        stage('Get Docker Digest and Update YAML') {
            steps {
                script {
                    // Pull the image to ensure it's available
                    sh "docker pull ${HARBOR_REGISTRY}/${params.BASE_IMAGE_NAME}"

                    // Get the image digest
                    def dockerInspectOutput = sh(
                        script: "docker inspect --format='{{index .RepoDigests 0}}' ${HARBOR_REGISTRY}/${params.BASE_IMAGE_NAME}",
                        returnStdout: true
                    ).trim()

                    // Check if dockerInspectOutput contains '@' to split
                    if (!dockerInspectOutput.contains('@')) {
                        error("Failed to retrieve digest for image ${HARBOR_REGISTRY}/${params.BASE_IMAGE_NAME}. Output: ${dockerInspectOutput}")
                    }

                    // Extract the digest part
                    def dockerDigest = dockerInspectOutput.split('@')[1]
                    echo "Docker Digest: ${dockerDigest}"

                    // Update the YAML file with the new image and digest
                    sh """
                        sed -i 's|image:.*|image: ${HARBOR_REGISTRY}/${params.BASE_IMAGE_NAME}@${dockerDigest}|' ${PATH_YAML}
                    """
                }
            }
        }

        stage('Commit and Push Changes to Git') {
            steps {
                withCredentials([usernamePassword(credentialsId: 'github-credentials-amir', passwordVariable: 'GITHUB_PASSWORD', usernameVariable: 'GITHUB_USERNAME')]) {
                    script {
                        // Sanitize GIT_URL by removing 'https://'
                        def sanitizedGitUrl = params.GIT_URL.replace('https://', '')
                        def gitUrlWithCredentials = "https://${GITHUB_USERNAME}:${GITHUB_PASSWORD}@${sanitizedGitUrl}"

                        // Configure Git with credentials and set remote URL
                        sh """
                            git config user.name "$GITHUB_USERNAME"
                            git config user.email "amundeadz@yahoo.com"
                            git remote set-url origin ${gitUrlWithCredentials}
                        """

                        // Pull the latest changes to avoid conflicts
                        sh """
                            git pull origin main --rebase
                        """

                        // Add, commit, and push changes
                        sh """
                            git add ${PATH_YAML}
                            git commit -m "Update image in YAML to ${HARBOR_REGISTRY}/${params.BASE_IMAGE_NAME}@${dockerDigest}" || echo "No changes to commit"
                            git push origin HEAD:main
                        """
                    }
                }
            }
        }

        stage('Trigger ArgoCD Sync') {
            steps {
                withCredentials([usernamePassword(credentialsId: 'kargo-credentials', usernameVariable: 'ARGOCD_USERNAME', passwordVariable: 'ARGOCD_PASSWORD')]) {
                    script {
                        // Obtain ArgoCD auth token
                        def token = sh(
                            script: """
                                curl -s -X POST -k -d '{ "username": "${ARGOCD_USERNAME}", "password": "${ARGOCD_PASSWORD}" }' -H 'Content-Type: application/json' https://${ARGOCD_SERVER}/api/v1/session | jq -r .token
                            """,
                            returnStdout: true
                        ).trim()

                        // Check if application exists
                        def appExists = sh(
                            script: """
                                curl -s -X GET -k -H "Authorization: Bearer ${token}" -H "Content-Type: application/json" https://${ARGOCD_SERVER}/api/v1/applications | jq -r '.items[] | select(.metadata.name == "${params.APP_NAME}")'
                            """,
                            returnStdout: true
                        ).trim()

                        if (appExists) {
                            // Trigger ArgoCD sync
                            sh """
                                curl -s -X POST -k -H "Authorization: Bearer ${token}" -H "Content-Type: application/json" https://${ARGOCD_SERVER}/api/v1/applications/${params.APP_NAME}/sync
                            """
                        } else {
                            error("Application '${params.APP_NAME}' does not exist in Argo CD. Please check the application name.")
                        }
                    }
                }
            }
        }
    }

    post {
        always {
            cleanWs()
        }
        success {
            echo "Pipeline completed successfully!"
        }
        failure {
            echo "Pipeline failed."
        }
    }
}
